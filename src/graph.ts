// Copyright 2016-2022, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { debug } from '@pulumi/pulumi/log';
import { CloudFormationResource } from './cfn';
import { parseSub } from './sub';
import { ConstructTree, StackManifest } from './assembly';

// Represents a value that will be used as the (or part of the) pulumi resource
// type token
export type PulumiResourceType = string;

/**
 * Represents a CDK Construct
 */
export interface ConstructInfo {
    /**
     * The construct path
     */
    path: string;

    /**
     * The node id of the construct
     */
    id: string;

    /**
     * The value to use as part of the Pulumi resource type
     */
    type: PulumiResourceType;

    /**
     * The attributes of the construct
     */
    attributes?: { [key: string]: any };

    /**
     * The parent construct (i.e. scope)
     * Will be undefined for the construct representing the `Stack`
     */
    parent?: ConstructInfo;

    constructInfo?: ConstructMetadata;
}

export interface ConstructMetadata {
    "fqn": string;
    "version": string;
}

export interface GraphNode {
    incomingEdges: Set<GraphNode>;
    outgoingEdges: Set<GraphNode>;
    /**
     * The CFN LogicalID.
     *
     * This will only be set if this node represents a CloudFormation resource.
     * It will not be set for wrapper constructs
     */
    logicalId?: string;

    /**
     * The info on the Construct this node represents
     */
    construct: ConstructInfo;

    /**
     * The CloudFormation resource data for the resource represented by this node.
     * This will only be set if this node represents a cfn resource (not a wrapper construct)
     */
    resource?: CloudFormationResource;
}

/**
 * Get the 'type' from the CFN Type
 * `AWS::S3::Bucket` => `Bucket`
 *
 * @param cfnType - The CloudFormation type (i.e. AWS::S3::Bucket)
 * @returns The resource type (i.e. Bucket)
 */
function typeFromCfn(cfnType: string): string {
    const typeParts = cfnType.split('::');
    if (typeParts.length !== 3) {
        throw new Error(`Expected cfn type in format 'AWS::Service::Resource', got ${cfnType}`);
    }
    return typeParts[2];
}

/**
 * Get the 'type' from the FQN
 *
 * The fqn is automatically generated by JSII and is in the format `module.submodule.ClassName`
 *
 * For example,
 *    import { Bucket } from 'aws-cdk-lib/aws-s3';
 * `Bucket` would have the fqn of `aws-cdk-lib.aws-s3.Bucket`
 * and we would return `aws-cdk-lib/aws-s3:Bucket`
 *
 * @param fqn - The fully qualified name of the construct
 * @returns The pulumi resource type (i.e. aws-cdk-lib/aws-s3:Bucket)
 */
function typeFromFqn(fqn: string): PulumiResourceType {
    const fqnParts = fqn.split('.');
    const mod = fqnParts.slice(0, fqnParts.length - 1).join('/');
    const type = fqnParts[fqnParts.length - 1];
    return `${mod}:${type}`;
}

/**
 * Represents the dependency graph of the constructs in the CDK app
 */
export interface Graph {
    /**
     * The nodes in the graph sorted in topological order
     */
    nodes: GraphNode[];

    /**
     * The VPC nodes in the graph
     */
    vpcNodes: { [logicalId: string]: VpcGraphNode };
}

/**
 * Represents a VPC and its (optionally) associated VPCCidrBlock
 */
export interface VpcGraphNode {
    /**
     * The GraphNode representing the VPC
     */
    vpcNode: GraphNode;

    /**
     * The GraphNode representing the VPCCidrBlock
     */
    vpcCidrBlockNode?: GraphNode;
}

export class GraphBuilder {
    // Allows for easy access to the GraphNode of a specific Construct
    constructNodes: Map<ConstructInfo, GraphNode>;
    // Map of resource logicalId to GraphNode. Allows for easy lookup by logicalId
    cfnElementNodes: Map<string, GraphNode>;

    // If the app has a VpcCidrBlock resource, this will be set to the GraphNode representing it
    private readonly _vpcCidrBlockNodes: { [logicalId: string]: GraphNode } = {};
    // If the app has a Vpc resource, this will be set to the GraphNode representing it
    private readonly vpcNodes: { [logicalId: string]: VpcGraphNode } = {};

    constructor(private readonly stack: StackManifest) {
        this.constructNodes = new Map<ConstructInfo, GraphNode>();
        this.cfnElementNodes = new Map<string, GraphNode>();
    }

    // build constructs a dependency graph from the adapter and returns its nodes sorted in topological order.
    public static build(stack: StackManifest): Graph {
        return new GraphBuilder(stack)._build();
    }

    /**
     * Recursively parses the construct tree to create:
     * - constructNodes
     * - cfnElementNodes
     *
     * @param tree - The construct tree of the current construct being parsed
     * @param parent - The parent construct of the construct currently being parsed
     */
    private parseTree(tree: ConstructTree, parent?: ConstructInfo) {
        const construct: ConstructInfo = {
            parent,
            id: tree.id,
            path: tree.path,
            type: tree.constructInfo ? typeFromFqn(tree.constructInfo.fqn) : tree.id,
            attributes: tree.attributes,
            constructInfo: tree.constructInfo,
        };
        const node: GraphNode = {
            incomingEdges: new Set<GraphNode>(),
            outgoingEdges: new Set<GraphNode>(),
            construct,
        };
        if (tree.attributes && 'aws:cdk:cloudformation:type' in tree.attributes) {
            const cfnType = tree.attributes['aws:cdk:cloudformation:type'] as string;
            const logicalId = this.stack.logicalIdForPath(tree.path);
            const resource = this.stack.resourceWithLogicalId(logicalId);
            const typ = typeFromCfn(cfnType);
            node.construct.type = typ;
            construct.type = typ;
            if (resource.Type === cfnType) {
                node.resource = resource;
                node.logicalId = logicalId;
                this.cfnElementNodes.set(logicalId, node);
            } else {
                throw new Error(
                    `Something went wrong: resourceType ${resource.Type} does not equal CfnType ${cfnType}`,
                );
            }
            if (resource.Type === 'AWS::EC2::VPCCidrBlock') {
                this._vpcCidrBlockNodes[node.logicalId] = node;
            }
            if (resource.Type === 'AWS::EC2::VPC') {
                this.vpcNodes[node.logicalId] = { vpcNode: node, vpcCidrBlockNode: undefined };
            }
        } else if (node.construct.constructInfo?.fqn === 'aws-cdk-lib.CfnResource') {
            // If the construct is a CfnResource, then we need to treat it as a resource
            const logicalId = this.stack.logicalIdForPath(tree.path);
            const resource = this.stack.resourceWithLogicalId(logicalId);
            node.resource = resource;
            node.logicalId = logicalId;
            this.cfnElementNodes.set(logicalId, node);

            // Custom Resources do not map to types. E.g. Custom::Bucket should not map to Bucket
            if (!GraphBuilder.isCustomResource(tree, parent)) {
                node.construct.type = typeFromCfn(resource.Type);
            }
        }

        this.constructNodes.set(construct, node);
        if (tree.children) {
            Object.values(tree.children).forEach((child) => this.parseTree(child, construct));
        }
    }

    private static isCustomResource(node: ConstructTree, parent?: ConstructInfo): boolean {
        // CDK CustomResource are exposed as a CfnResource with the ID "Default"
        // If the parent construct has the fqn of CustomResource and the current tree node is the "Default" node
        // then we need to treat it as a Custom Resource
        return parent?.constructInfo?.fqn === 'aws-cdk-lib.CustomResource' && node.id === 'Default'
    }

    private _build(): Graph {
        // passes
        // 1. collect all constructs into a map from construct name to DAG node, converting CFN elements to fragments
        // 2. hook up dependency edges
        // 3. sort the dependency graph

        // Create graph nodes and associate them with constructs and CFN logical IDs.
        //
        // NOTE: this doesn't handle cross-stack references. We'll likely need to do so, at least for nested stacks.
        this.parseTree(this.stack.constructTree);

        // parseTree does not guarantee that the VPC resource will be parsed before the VPCCidrBlock resource
        // so we need to process this separately after
        if (Object.keys(this._vpcCidrBlockNodes).length) {
            Object.entries(this._vpcCidrBlockNodes).forEach(([logicalId, node]) => {
                const resource = node.resource;
                if (!resource) {
                    throw new Error(`Something went wrong. CFN Resource not found for VPCCidrBlock ${logicalId}`);
                }
                const vpcRef = resource.Properties.VpcId;
                if (typeof vpcRef === 'object' && 'Ref' in vpcRef) {
                    const vpcLogicalId = this.cfnElementNodes.get(vpcRef.Ref)?.logicalId;
                    if (!vpcLogicalId) {
                        throw new Error(`VPC resource ${vpcRef.Ref} not found for VPCCidrBlock ${node.logicalId}`);
                    }
                    const vpcNode = this.vpcNodes[vpcLogicalId];
                    // currently the CDK VPC only supports a single VPCCidrBlock per VPC so for now we won't allow multiple
                    // if we get requests for this we can update this to support multiple
                    if (vpcNode.vpcCidrBlockNode) {
                        throw new Error(`VPC ${vpcLogicalId} already has a VPCCidrBlock`);
                    }
                    vpcNode.vpcCidrBlockNode = node;
                }
            });
        }

        for (const [construct, node] of this.constructNodes) {
            // No parent means this is the construct that represents the `Stack`
            if (construct.parent !== undefined) {
                const parentNode = this.constructNodes.get(construct.parent)!;
                node.outgoingEdges.add(parentNode);
                parentNode.incomingEdges.add(node);
            }

            // Then this is the construct representing the CFN resource (i.e. not a wrapper construct)
            if (node.resource && node.logicalId) {
                const source = this.cfnElementNodes.get(node.logicalId!)!;
                this.addEdgesForCfnResource(node.resource, source);

                const dependsOn =
                    typeof node.resource.DependsOn === 'string' ? [node.resource.DependsOn] : node.resource.DependsOn;
                if (dependsOn !== undefined) {
                    for (const target of dependsOn) {
                        this.addEdgeForRef(target, source);
                    }
                }
            }
        }

        // Sort the graph.
        const sorted: GraphNode[] = [];
        const visited = new Set<GraphNode>();
        function sort(node: GraphNode) {
            if (visited.has(node)) {
                return;
            }
            visited.add(node);

            // If this is a non-CFN construct with no incoming edges, ignore it.
            if (!node.resource && node.incomingEdges.size == 0) {
                return;
            }

            for (const target of node.outgoingEdges) {
                sort(target);
            }
            sorted.push(node);
        }

        for (const [_, node] of this.constructNodes) {
            sort(node);
        }

        return {
            nodes: sorted,
            vpcNodes: this.vpcNodes,
        };
    }

    private addEdgesForCfnResource(obj: any, source: GraphNode): void {
        // Since we are processing the final CloudFormation template, strings will always
        // be the fully resolved value
        if (typeof obj === 'string') {
            return;
        }

        if (typeof obj !== 'object') {
            return;
        }

        if (Array.isArray(obj)) {
            obj.map((x) => this.addEdgesForCfnResource(x, source));
            return;
        }

        const ref = obj.Ref;
        if (ref) {
            this.addEdgeForRef(ref, source);
            return;
        }

        const keys = Object.keys(obj);
        if (keys.length == 1 && keys[0]?.startsWith('Fn::')) {
            this.addEdgesForIntrinsic(keys[0], obj[keys[0]], source);
            return;
        }

        for (const v of Object.values(obj)) {
            this.addEdgesForCfnResource(v, source);
        }
    }

    private addEdgeForRef(args: any, source: GraphNode) {
        if (typeof args !== 'string') {
            // Ignore these--they are either malformed references or Pulumi outputs.
            return;
        }
        const targetLogicalId = args;

        debug(`ref to ${args}`);
        if (!targetLogicalId.startsWith('AWS::')) {
            const targetNode = this.cfnElementNodes.get(targetLogicalId);
            if (targetNode === undefined) {
                debug(`missing node for target element ${targetLogicalId}`);
            } else {
                source.outgoingEdges.add(targetNode);
                targetNode.incomingEdges.add(source);
            }
        }
    }

    private addEdgesForIntrinsic(fn: string, params: any, source: GraphNode) {
        switch (fn) {
            case 'Fn::GetAtt': {
                let logicalId = params[0];
                const attributeName = params[1];
                // Special case for VPC Ipv6CidrBlocks
                // Ipv6 cidr blocks are added to the VPC through a separate VpcCidrBlock resource
                // Due to [pulumi/pulumi-aws-native#1798] the `Ipv6CidrBlocks` attribute will always be empty
                // and we need to instead pull the `Ipv6CidrBlock` attribute from the VpcCidrBlock resource.
                // Here we switching the dependency to be on the `VpcCidrBlock` resource (since that will also have a dependency
                // on the VPC resource)
                if (
                    logicalId in this.vpcNodes &&
                    attributeName === 'Ipv6CidrBlocks' &&
                    this.vpcNodes[logicalId].vpcCidrBlockNode?.logicalId
                ) {
                    logicalId = this.vpcNodes[logicalId].vpcCidrBlockNode!.logicalId;
                }
                this.addEdgeForRef(logicalId, source);
                break;
            }
            case 'Fn::Sub':
                {
                    const [template, vars] =
                        typeof params === 'string' ? [params, undefined] : [params[0] as string, params[1]];

                    this.addEdgesForCfnResource(vars, source);

                    for (const part of parseSub(template).filter((p) => p.ref !== undefined)) {
                        this.addEdgeForRef(part.ref!.id, source);
                    }
                }
                break;
            default:
                this.addEdgesForCfnResource(params, source);
                break;
        }
    }
}
