// Copyright 2016-2022, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { debug, warn } from '@pulumi/pulumi/log';
import { CloudFormationResource } from './cfn';
import { parseSub } from './sub';
import { ConstructTree, StackAddress, StackManifest } from './assembly';
import { CdkAdapterError } from './types';
import { StackMap } from './stack-map';
import { Node } from 'aws-cdk-lib/core/lib/private/tree-metadata';

// Represents a value that will be used as the (or part of the) pulumi resource
// type token
export type PulumiResourceType = string;

interface NestedStackData {
    // The stack address of the nested stack resource. Uniquely identifies the nested stack resource across all stacks.
    resourceAddress: StackAddress;
    // The CloudFormation resource (AWS::CloudFormation::Stack) that represents the nested stack
    resource: CloudFormationResource;
    // The graph node representing the nested stack. It contains all the children of the nested stack.
    node: Node;
}

/**
 * Represents a CDK Construct
 */
export interface ConstructInfo {
    /**
     * The construct path
     */
    path: string;

    /**
     * The node id of the construct
     */
    id: string;

    /**
     * The value to use as part of the Pulumi resource type
     */
    type: PulumiResourceType;

    /**
     * The attributes of the construct
     */
    attributes?: { [key: string]: any };

    /**
     * The parent construct (i.e. scope)
     * Will be undefined for the construct representing the `Stack`
     */
    parent?: ConstructInfo;

    constructInfo?: ConstructMetadata;
}

export interface ConstructMetadata {
    fqn: string;
    version: string;
}

export interface GraphNode {
    incomingEdges: Set<GraphNode>;
    outgoingEdges: Set<GraphNode>;

    /**
     * The StackAddress uniquely identifying the CFN resource in the (nested) stacks.
     *
     * This will only be set if this node represents a CloudFormation resource.
     * It will not be set for wrapper constructs
     */
    resourceAddress?: StackAddress;

    /**
     * The info on the Construct this node represents
     */
    construct: ConstructInfo;

    /**
     * The CloudFormation resource data for the resource represented by this node.
     * This will only be set if this node represents a cfn resource (not a wrapper construct)
     */
    resource?: CloudFormationResource;
}

/**
 * Get the 'type' from the CFN Type
 * `AWS::S3::Bucket` => `Bucket`
 *
 * @param cfnType - The CloudFormation type (i.e. AWS::S3::Bucket)
 * @returns The resource type (i.e. Bucket)
 */
function typeFromCfn(cfnType: string): string {
    const typeParts = cfnType.split('::');
    if (typeParts.length !== 3) {
        throw new CdkAdapterError(`Expected cfn type in format 'AWS::Service::Resource', got ${cfnType}`);
    }
    return typeParts[2];
}

/**
 * Get the 'type' from the FQN
 *
 * The fqn is automatically generated by JSII and is in the format `module.submodule.ClassName`
 *
 * For example,
 *    import { Bucket } from 'aws-cdk-lib/aws-s3';
 * `Bucket` would have the fqn of `aws-cdk-lib.aws-s3.Bucket`
 * and we would return `aws-cdk-lib/aws-s3:Bucket`
 *
 * @param fqn - The fully qualified name of the construct
 * @returns The pulumi resource type (i.e. aws-cdk-lib/aws-s3:Bucket)
 */
function typeFromFqn(fqn: string): PulumiResourceType {
    const fqnParts = fqn.split('.');
    const mod = fqnParts.slice(0, fqnParts.length - 1).join('/');
    const type = fqnParts[fqnParts.length - 1];
    return `${mod}:${type}`;
}

/**
 * Represents the dependency graph of the constructs in the CDK app
 */
export interface Graph {
    /**
     * The nodes in the graph sorted in topological order
     */
    nodes: GraphNode[];

    /**
     * The VPC nodes in the graph
     */
    vpcNodes: StackMap<VpcGraphNode>;

    /**
     * The nested stack nodes in the graph indexed by the stack path
     */
    nestedStackNodes: Map<string, GraphNode>;
}

/**
 * Represents a VPC and its (optionally) associated VPCCidrBlock
 */
export interface VpcGraphNode {
    /**
     * The GraphNode representing the VPC
     */
    vpcNode: GraphNode;

    /**
     * The GraphNode representing the VPCCidrBlock
     */
    vpcCidrBlockNode?: GraphNode;
}

export class GraphBuilder {
    // Allows for easy access to the GraphNode of a specific Construct
    constructNodes: Map<ConstructInfo, GraphNode>;
    // Map of stack address to GraphNode. Allows for easy lookup by stack address
    cfnElementNodes: StackMap<GraphNode>;

    // If the app has a VpcCidrBlock resource, this will be set to the GraphNode representing it
    private readonly _vpcCidrBlockNodes: StackMap<GraphNode>;
    // If the app has a Vpc resource, this will be set to the GraphNode representing it
    private readonly vpcNodes: StackMap<VpcGraphNode>;
    // Map of stack path to GraphNode of nested stacks. Allows for looking up the nested stack node by stack path
    private readonly nestedStackNodes: Map<string, GraphNode>;

    constructor(private readonly stack: StackManifest) {
        this.constructNodes = new Map<ConstructInfo, GraphNode>();
        this.cfnElementNodes = new StackMap<GraphNode>();
        this._vpcCidrBlockNodes = new StackMap<GraphNode>();
        this.vpcNodes = new StackMap<VpcGraphNode>();
        this.nestedStackNodes = new Map<string, GraphNode>();
    }

    // build constructs a dependency graph from the adapter and returns its nodes sorted in topological order.
    public static build(stack: StackManifest): Graph {
        return new GraphBuilder(stack)._build();
    }

    /**
     * Recursively parses the construct tree to create:
     * - constructNodes
     * - cfnElementNodes
     *
     * @param tree - The construct tree of the current construct being parsed
     * @param parent - The parent construct of the construct currently being parsed
     */
    private parseTree(tree: ConstructTree, parent?: ConstructInfo) {
        const construct: ConstructInfo = {
            parent,
            id: tree.id,
            path: tree.path,
            type: tree.constructInfo ? typeFromFqn(tree.constructInfo.fqn) : tree.id,
            attributes: tree.attributes,
            constructInfo: tree.constructInfo,
        };

        const node: GraphNode = {
            incomingEdges: new Set<GraphNode>(),
            outgoingEdges: new Set<GraphNode>(),
            construct,
        };
        if (tree.attributes && 'aws:cdk:cloudformation:type' in tree.attributes) {
            const cfnType = tree.attributes['aws:cdk:cloudformation:type'] as string;
            const resourceAddress = this.stack.resourceAddressForPath(tree.path);
            const resource = this.stack.resourceWithLogicalId(resourceAddress.stackPath, resourceAddress.id);
            const typ = typeFromCfn(cfnType);
            node.construct.type = typ;
            construct.type = typ;
            if (resource.Type === cfnType) {
                node.resource = resource;
                node.resourceAddress = resourceAddress;
                this.cfnElementNodes.set(resourceAddress, node);
            } else {
                throw new CdkAdapterError(
                    `Something went wrong: resourceType ${resource.Type} does not equal CfnType ${cfnType}`,
                );
            }
            if (resource.Type === 'AWS::EC2::VPCCidrBlock') {
                this._vpcCidrBlockNodes.set(resourceAddress, node);
            }
            if (resource.Type === 'AWS::EC2::VPC') {
                this.vpcNodes.set(resourceAddress, { vpcNode: node, vpcCidrBlockNode: undefined });
            }
        } else if (node.construct.constructInfo?.fqn === 'aws-cdk-lib.CfnResource') {
            // If the construct is a CfnResource, then we need to treat it as a resource
            const resourceAddress = this.stack.resourceAddressForPath(tree.path);
            const resource = this.stack.resourceWithLogicalId(resourceAddress.stackPath, resourceAddress.id);
            node.resource = resource;
            node.resourceAddress = resourceAddress;
            this.cfnElementNodes.set(resourceAddress, node);

            // Custom Resources do not map to types. E.g. Custom::Bucket should not map to Bucket
            if (!GraphBuilder.isCustomResource(tree, parent)) {
                node.construct.type = typeFromCfn(resource.Type);
            }
        }

        this.constructNodes.set(construct, node);

        const nestedStacks = this.findNestedStacks(tree);
        nestedStacks.forEach((nestedStack) => {
            const nestedStackConstruct: ConstructInfo = {
                parent: construct,
                id: nestedStack.node.id,
                path: nestedStack.node.path,
                type: typeFromCfn('AWS::CloudFormation::Stack'),
                constructInfo: nestedStack.node.constructInfo,
            };

            const node: GraphNode = {
                incomingEdges: new Set<GraphNode>(),
                outgoingEdges: new Set<GraphNode>(),
                construct: nestedStackConstruct,
                resource: nestedStack.resource,
                resourceAddress: nestedStack.resourceAddress,
            };

            this.cfnElementNodes.set(nestedStack.resourceAddress, node);
            this.constructNodes.set(nestedStackConstruct, node);
            this.nestedStackNodes.set(nestedStack.node.path, node);

            // load all the children of the nested stack
            Object.values(nestedStack.node.children ?? {}).forEach((child) =>
                this.parseTree(child, nestedStackConstruct),
            );
        });

        // handle all the children of the current construct that are not nested stacks
        if (tree.children) {
            Object.values(tree.children)
                .filter(
                    (child) =>
                        !nestedStacks.find(
                            (nestedStack) =>
                                nestedStack.node.id === child.id || child.id === `${nestedStack.node.id}.NestedStack`,
                        ),
                )
                .forEach((child) => this.parseTree(child, construct));
        }
    }

    /**
     * Finds all the nested stacks in the children of the current construct tree node.
     * It identifies nested stacks by matching a nested stack resource node (named `NAME.NestedStack`)
     * with a child that is a 'AWS::CloudFormation::Stack' to a tree node (named `NAME`) that includes
     * all the children of the nested stack.
     *
     * The tree structure looks like this:
     * ```
     * Root
     * ├── MyNestedStack.NestedStack (Nested Stack Resource Node)
     * │   └── AWS::CloudFormation::Stack
     * │       └── Properties
     * │           └── Parameters
     * │               └── MyParameter
     * │
     * ├── MyNestedStack (Nested Stack Node)
     * │   ├── ChildResource1
     * │   │   └── Properties
     * │   └── ChildResource2
     * │       └── Properties
     * ```
     *
     * @param tree - The construct tree node to search
     * @returns The nested stacks found in the construct tree
     */
    private findNestedStacks(tree: ConstructTree): NestedStackData[] {
        // find the nested stack resources. Those are nodes that have a name ending in `.NestedStack`
        // and have a child that is a 'AWS::CloudFormation::Stack' resource
        const nestedStackResources = Object.values(tree.children ?? {})
            .map((child) => {
                if (!child.id.endsWith('.NestedStack')) {
                    return undefined;
                }

                return Object.values(child.children ?? {}).find((child) => {
                    return (
                        child.attributes &&
                        'aws:cdk:cloudformation:type' in child.attributes &&
                        child.attributes['aws:cdk:cloudformation:type'] === 'AWS::CloudFormation::Stack'
                    );
                });
            })
            .filter((x) => x !== undefined);

        const nestedStacks = nestedStackResources
            .map((nestedStackResourceNode) => {
                debug(
                    `Found potential nested stack resource ${nestedStackResourceNode.id} in ${nestedStackResourceNode.path}`,
                );
                const nestedStackPath = StackManifest.getNestedStackPath(
                    nestedStackResourceNode.path,
                    nestedStackResourceNode.id,
                );
                const resourceAddress = this.stack.resourceAddressForPath(nestedStackResourceNode.path);
                const resource = this.stack.resourceWithLogicalId(resourceAddress.stackPath, resourceAddress.id);

                // the nested stack node is the node that contains all the child nodes of the nested stack
                // and is on the same level as the nested stack resource node. Its path should match the
                // nestedStackPath that was computed above
                const nestedStackNode = Object.values(tree.children ?? {}).find(
                    (child) => child.path === nestedStackPath,
                );

                if (!nestedStackNode) {
                    // This is not a nested CDK stack, but just a regular CFN stack that accidentally follows the CDK naming
                    debug(
                        `CloudFormation stack ${nestedStackResourceNode.id} in ${nestedStackResourceNode.path} does not correspond to a nested CDK stack. Handling it as a regular resource.`,
                    );
                    return;
                }

                return nestedStackResourceNode
                    ? {
                          resource,
                          node: nestedStackNode,
                          resourceAddress,
                      }
                    : undefined;
            })
            .filter((x) => x !== undefined);
        return nestedStacks;
    }

    private static isCustomResource(node: ConstructTree, parent?: ConstructInfo): boolean {
        // CDK CustomResource are exposed as a CfnResource with the ID "Default"
        // If the parent construct has the fqn of CustomResource and the current tree node is the "Default" node
        // then we need to treat it as a Custom Resource
        return parent?.constructInfo?.fqn === 'aws-cdk-lib.CustomResource' && node.id === 'Default';
    }

    private _build(): Graph {
        // passes
        // 1. collect all constructs into a map from construct name to DAG node, converting CFN elements to fragments
        // 2. validate that all CDK resources are mapped to Pulumi resources
        // 3. hook up dependency edges
        // 4. sort the dependency graph

        // Create graph nodes and associate them with constructs and CFN logical IDs.
        //
        // NOTE: this doesn't handle cross-stack references. We'll likely need to do so, at least for nested stacks.
        this.parseTree(this.stack.constructTree);

        const unmappedResources: string[] = [];
        Object.entries(this.stack.stacks).map(([stackPath, template]) => {
            Object.entries(template.Resources ?? {}).map(([logicalId, resource]) => {
                if (!this.cfnElementNodes.has({ id: logicalId, stackPath })) {
                    warn(`CDK resource ${logicalId} (${resource.Type}) was not mapped to a Pulumi resource.`);
                    unmappedResources.push(logicalId);
                }
            });
        });

        if (unmappedResources.length > 0) {
            const total = Object.entries(this.stack.stacks)
                .map(([_, template]) => Object.keys(template.Resources ?? {}).length)
                .reduce((a, b) => a + b, 0);
            throw new CdkAdapterError(
                `${unmappedResources.length} out of ${total} CDK resources failed to map to Pulumi resources.`,
            );
        }

        // parseTree does not guarantee that the VPC resource will be parsed before the VPCCidrBlock resource
        // so we need to process this separately after
        if (this._vpcCidrBlockNodes.size > 0) {
            this._vpcCidrBlockNodes.forEach((node, resourceAddress) => {
                const resource = node.resource;
                if (!resource || !node.resourceAddress) {
                    throw new CdkAdapterError(
                        `Something went wrong. CFN Resource not found for VPCCidrBlock ${resourceAddress.id} in stack ${resourceAddress.stackPath}`,
                    );
                }
                const vpcRef = resource.Properties.VpcId;
                if (typeof vpcRef === 'object' && 'Ref' in vpcRef) {
                    const vpcResourceAddress = this.cfnElementNodes.get({
                        stackPath: node.resourceAddress.stackPath,
                        id: vpcRef.Ref,
                    })?.resourceAddress;
                    if (!vpcResourceAddress) {
                        throw new CdkAdapterError(
                            `VPC resource ${vpcRef.Ref} not found for VPCCidrBlock ${resourceAddress.id} in stack ${resourceAddress.stackPath}`,
                        );
                    }
                    const vpcNode = this.vpcNodes.get(vpcResourceAddress);
                    if (!vpcNode) {
                        throw new CdkAdapterError(
                            `VPC resource ${vpcRef.Ref} not found for VPCCidrBlock ${resourceAddress.id} in stack ${resourceAddress.stackPath}`,
                        );
                    }

                    // currently the CDK VPC only supports a single VPCCidrBlock per VPC so for now we won't allow multiple
                    // if we get requests for this we can update this to support multiple
                    if (vpcNode.vpcCidrBlockNode) {
                        throw new CdkAdapterError(
                            `VPC ${vpcResourceAddress.id} in stack ${resourceAddress.stackPath} already has a VPCCidrBlock`,
                        );
                    }
                    vpcNode.vpcCidrBlockNode = node;
                }
            });
        }

        for (const [construct, node] of this.constructNodes) {
            // No parent means this is the construct that represents the root `Stack`
            if (construct.parent !== undefined) {
                const parentNode = this.constructNodes.get(construct.parent)!;
                node.outgoingEdges.add(parentNode);
                parentNode.incomingEdges.add(node);
            }

            // Then this is the construct representing the CFN resource (i.e. not a wrapper construct)
            if (node.resource && node.resourceAddress) {
                const source = this.cfnElementNodes.get(node.resourceAddress);
                if (!source) {
                    throw new CdkAdapterError(
                        `CFN Resource not found for ${node.resourceAddress.id} in stack ${node.resourceAddress.stackPath}`,
                    );
                }

                this.addEdgesForCfnResource(node.resource, source);

                const dependsOn =
                    typeof node.resource.DependsOn === 'string' ? [node.resource.DependsOn] : node.resource.DependsOn;
                if (dependsOn !== undefined) {
                    for (const target of dependsOn) {
                        this.addEdgeForRef(target, source);
                    }
                }
            }
        }

        // Sort the graph.
        const sorted: GraphNode[] = [];
        const visited = new Set<GraphNode>();
        function sort(node: GraphNode) {
            if (visited.has(node)) {
                return;
            }
            visited.add(node);

            // If this is a non-CFN construct with no incoming edges, ignore it.
            if (!node.resource && node.incomingEdges.size == 0) {
                return;
            }

            for (const target of node.outgoingEdges) {
                sort(target);
            }
            sorted.push(node);
        }

        for (const [_, node] of this.constructNodes) {
            sort(node);
        }

        return {
            nodes: sorted,
            vpcNodes: this.vpcNodes,
            nestedStackNodes: this.nestedStackNodes,
        };
    }

    private addEdgesForCfnResource(obj: any, source: GraphNode, stackPath?: string): void {
        // Since we are processing the final CloudFormation template, strings will always
        // be the fully resolved value
        if (typeof obj === 'string') {
            return;
        }

        if (typeof obj !== 'object') {
            return;
        }

        if (Array.isArray(obj)) {
            obj.map((x) => this.addEdgesForCfnResource(x, source, stackPath));
            return;
        }

        const ref = obj.Ref;
        if (ref) {
            this.addEdgeForRef(ref, source, stackPath);
            return;
        }

        const keys = Object.keys(obj);
        if (keys.length == 1 && keys[0]?.startsWith('Fn::')) {
            this.addEdgesForIntrinsic(keys[0], obj[keys[0]], source, stackPath);
            return;
        }

        for (const v of Object.values(obj)) {
            this.addEdgesForCfnResource(v, source, stackPath);
        }
    }

    private addEdgeForRef(args: any, source: GraphNode, stackPath?: string) {
        if (typeof args !== 'string') {
            // Ignore these--they are either malformed references or Pulumi outputs.
            return;
        }
        const targetLogicalId = args;
        stackPath = stackPath ?? source.resourceAddress?.stackPath;
        if (!stackPath) {
            throw new CdkAdapterError(
                `Resource address not set for source node ${source.construct.path}. Cannot locate the source resource.`,
            );
        }

        debug(`ref to ${args}`);
        if (!targetLogicalId.startsWith('AWS::')) {
            const targetNode = this.cfnElementNodes.get({
                id: targetLogicalId,
                stackPath,
            });
            if (targetNode === undefined) {
                // If this is a nested stack, we need to check if the parameter is set by the parent stack
                if (!this.stack.isRootStack(stackPath)) {
                    const nestedStackNode = this.nestedStackNodes.get(stackPath);
                    if (nestedStackNode?.resource?.Properties?.Parameters?.[targetLogicalId]) {
                        debug(`Parameter ${targetLogicalId} is set by the parent stack ${stackPath}`);
                        return;
                    }
                }

                debug(`missing node for target element ${targetLogicalId}`);
            } else {
                source.outgoingEdges.add(targetNode);
                targetNode.incomingEdges.add(source);
            }
        }
    }

    private addEdgesForIntrinsic(fn: string, params: any, source: GraphNode, stackPath?: string) {
        switch (fn) {
            case 'Fn::GetAtt': {
                let logicalId = params[0];
                const attributeName = params[1];

                stackPath = stackPath ?? source.resourceAddress?.stackPath;
                if (!stackPath) {
                    throw new CdkAdapterError(
                        `Resource address not set for source node ${source.construct.path}. Cannot locate the source resource.`,
                    );
                }

                const targetResourceAddress = { id: logicalId, stackPath };
                const targetNodePath = this.cfnElementNodes.get(targetResourceAddress)?.construct?.path;

                // If the target node is a nested stack, we need to add an edge from the source to the nested stack's output
                if (targetNodePath && targetNodePath in this.stack.stacks) {
                    const nestedStack = this.stack.stacks[targetNodePath];

                    // For nested stacks, the attribute name is the output name without the `Outputs.` prefix
                    const outputName = attributeName.replace(/^Outputs\./, '');
                    if (nestedStack.Outputs?.[outputName]?.Value) {
                        this.addEdgesForCfnResource(nestedStack.Outputs[outputName].Value, source, targetNodePath);
                    }
                }

                // Special case for VPC Ipv6CidrBlocks
                // Ipv6 cidr blocks are added to the VPC through a separate VpcCidrBlock resource
                // Due to [pulumi/pulumi-aws-native#1798] the `Ipv6CidrBlocks` attribute will always be empty
                // and we need to instead pull the `Ipv6CidrBlock` attribute from the VpcCidrBlock resource.
                // Here we switching the dependency to be on the `VpcCidrBlock` resource (since that will also have a dependency
                // on the VPC resource)
                if (
                    this.vpcNodes.has(targetResourceAddress) &&
                    attributeName === 'Ipv6CidrBlocks' &&
                    this.vpcNodes.get(targetResourceAddress)?.vpcCidrBlockNode?.resourceAddress
                ) {
                    logicalId = this.vpcNodes.get(targetResourceAddress)!.vpcCidrBlockNode!.resourceAddress!.id;
                }
                this.addEdgeForRef(logicalId, source, stackPath);
                break;
            }
            case 'Fn::Sub':
                {
                    const [template, vars] =
                        typeof params === 'string' ? [params, undefined] : [params[0] as string, params[1]];

                    this.addEdgesForCfnResource(vars, source, stackPath);

                    for (const part of parseSub(template).filter((p) => p.ref !== undefined)) {
                        this.addEdgeForRef(part.ref!.id, source, stackPath);
                    }
                }
                break;
            default:
                this.addEdgesForCfnResource(params, source, stackPath);
                break;
        }
    }
}
